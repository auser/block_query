package grammar

type BlockQuery Peg {
  Query

  strStack []string
  workingWord string
  ExprStack ExprStack
}

# Rules
Result <- queryStmt semi? !.

queryStmt <- selectStmt (space queryExprs)*

queryExprs <- queryExpr (space queryExprs)*
queryExpr <- limitStmt / orderStmt / whereStmt

# Select statements
selectStmt <- select (star / WordList) fromStmt {
  p.Fields = p.strStack; p.strStack = []string{};
}
fromStmt <- space? from Word { p.Table = buffer[begin:end] }

# Limitation
limitStmt <- limit DecimalNumeral {
  f, _ := strconv.Atoi(text)
  p.Limit.ShouldLimit = true
  p.Limit.Count = f
}
# Ordering
orderStmt <- order by WordList { p.Order.Field = text }
(
  (space asc) { p.Order.Ordering = ASC }
  / (space desc) { p.Order.Ordering = DESC }
)?

# Conditionals
whereStmt <- where whereExprs
whereExprs <- whereExpr (space? whereExprs)*
whereExpr <-
  and whereExpr {
    p.ExprStack.Push(&NodeAnd{
      left: p.ExprStack.Pop(),
      right: p.ExprStack.Pop(),
    })
  }
  / or whereExpr {
    p.ExprStack.Push(&NodeOr{
      left: p.ExprStack.Pop(),
      right: p.ExprStack.Pop(),
    })
  }
  / Word equals StringLiteral {
    p.ExprStack.Push(&NodeEquals{
      left: p.workingWord,
      right: text,
    })
  }
  / Word equals DecimalNumeral {
    p.ExprStack.Push(&NodeEquals{
      left: p.workingWord,
      right: text,
    })
  }
  / Word greaterThan DecimalNumeral {
    f, _ := strconv.Atoi(text)
    p.ExprStack.Push(&NodeGreaterThan{
      left: p.workingWord,
      right: f,
    })
  }
  / Word greaterThanOrEq DecimalNumeral {
    f, _ := strconv.Atoi(text)
    p.ExprStack.Push(&NodeGreaterThanOrEqual{
      left: p.workingWord,
      right: f,
    })
  }
  / Word lessThan DecimalNumeral {
    f, _ := strconv.Atoi(text)
    p.ExprStack.Push(&NodeLessThan{
      left: p.workingWord,
      right: f,
    })
  }
  / Word lessThanOrEq DecimalNumeral {
    f, _ := strconv.Atoi(text)
    p.ExprStack.Push(&NodeLessThanOrEqual{
      left: p.workingWord,
      right: f,
    })
  }
  / Word notEq StringLiteral {
    p.ExprStack.Push(&NodeNotEqual{
      left: p.workingWord,
      right: text,
    })
  }
  / Word notEq DecimalNumeral {
    p.ExprStack.Push(&NodeNotEqual{
      left: p.workingWord,
      right: text,
    })
  }
  / Word inStmt (StringLiteralList / NumericList)

asc <- "ASC"
desc <- "DESC"
select <- "SELECT" space
from <- "FROM" space
order <- "ORDER" space
by <- "BY" space
star <- ('*' / "ALL") space { text = "star" }
limit <- "LIMIT" space
where <- "WHERE" space
and <- "AND" space
or <- "OR" space
inStmt <- space? "IN" space?
greaterThan <- space? '>' space?
lessThan <- space? '<' space?
greaterThanOrEq <- space? '>=' space?
lessThanOrEq <- space? '<=' space?
notEq <- space? '!=' space?
semi <- ';' space?
lparen <- '(' space?
rparen <- space? ')' space?
comma <- space? ',' space?

equals <- space? "=" space?

squote <- '\''
dquote <- '\"'

# Token matchers
StringLiteralList <- lparen StringLiteral (space? comma space? StringLiteral)* rparen
NumericList <- lparen DecimalNumeral (space? comma space? DecimalNumeral)* rparen

Letter <- [[a-z]]
LetterOrDigit <- [[a-z]] / [0-9]

HexDigit <- [[a-f]] / [0-9]
DecimalNumeral <- <'0' / [0-9] ([_]* [0-9])*>


StringChar <- Escape / ![ \'\"\n\\] .
StringLiteral <- < (squote / dquote)? StringChar* (squote / dquote)? >
Escape <- '\\' ([btnfr"'\\] / OctalEscape / UnicodeEscape)
OctalEscape
   <- [0-3][0-7][0-7]
    / [0-7][0-7]
    / [0-7]

UnicodeEscape
   <- 'u'+ HexDigit HexDigit HexDigit HexDigit

WordList <- Word  {
                    p.strStack = append(p.strStack, text)
                  }
            (space ',' space? WordList)*
Word <- < Letter LetterOrDigit* > { p.workingWord = text }

space <- ( [ \t\r\n]+              # WhiteSpace [ \t\r\n\u000C]+
      / '/*' (!'*/' .)* '*/'      # TraditionalComment
      / '//' (![\r\n] .)* [\r\n]  # EndOfLineComment
      )*
